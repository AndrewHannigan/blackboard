<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Blackboard</title>
  <link rel="stylesheet" href="./node_modules/highlight.js/styles/github-dark.css">
  <style>
    :root {
      --bg: #0d0d0d;
      --fg: #e0e0e0;
      --toggle-bg: #2a2a2a;
      --toggle-hover: #3a3a3a;
      --tab-border: #333;
      --tab-active: #0d0d0d;
      --tab-inactive: #181818;
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: var(--bg);
      transition: background 0.3s ease;
    }

    #app-container {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100%;
    }

    /* Tab bar styles */
    #tab-bar {
      display: none;
      flex-shrink: 0;
      width: 100%;
      background: var(--tab-inactive);
      border-bottom: 1px solid var(--tab-border);
    }

    #tab-bar.visible {
      display: flex;
    }

    .tab {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px 0;
      font-family: Monaco, Menlo, monospace;
      font-size: 12px;
      color: var(--fg);
      opacity: 0.5;
      background: var(--tab-inactive);
      border: none;
      border-right: 1px solid var(--tab-border);
      cursor: pointer;
      transition: opacity 0.15s ease, background 0.15s ease;
      position: relative;
    }

    .tab:last-child {
      border-right: none;
    }

    .tab:hover {
      opacity: 0.7;
      background: var(--toggle-bg);
    }

    .tab.active {
      opacity: 1;
      background: var(--tab-active);
    }

    .tab.active::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 40%;
      width: 20%;
      height: 2px;
      background: var(--fg);
      opacity: 0.5;
    }

    .tab-close {
      position: absolute;
      right: 8px;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
      opacity: 0;
      transition: opacity 0.1s ease, background 0.1s ease;
    }

    .tab:hover .tab-close,
    .tab.active .tab-close {
      opacity: 0.5;
    }

    .tab-close:hover {
      opacity: 1 !important;
      background: var(--toggle-hover);
    }

    .tab-close svg {
      width: 10px;
      height: 10px;
      fill: currentColor;
    }

    .tab-name {
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .tab-name-input {
      background: transparent;
      border: none;
      outline: none;
      color: inherit;
      font: inherit;
      text-align: center;
      width: 80px;
      padding: 0;
      margin: 0;
    }

    #add-tab {
      flex-shrink: 0;
      width: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px 0;
      font-family: Monaco, Menlo, monospace;
      font-size: 16px;
      color: var(--fg);
      opacity: 0.4;
      background: var(--tab-inactive);
      border: none;
      cursor: pointer;
      transition: opacity 0.15s ease, background 0.15s ease;
    }

    #add-tab:hover {
      opacity: 0.8;
      background: var(--toggle-bg);
    }

    #editor-container {
      position: relative;
      width: 100%;
      flex: 1;
      min-height: 0;
    }

    #editor, #highlight-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      padding: 12px;
      font-family: Monaco, Menlo, monospace;
      font-size: 13px;
      line-height: 1.7;
      border: none;
      margin: 0;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    #editor {
      outline: none;
      resize: none;
      background: transparent;
      color: transparent;
      caret-color: var(--fg);
      z-index: 2;
      -webkit-text-fill-color: transparent;
    }

    #editor::selection {
      background: rgba(100, 100, 255, 0.3);
    }

    #editor::-moz-selection {
      background: rgba(100, 100, 255, 0.3);
    }

    #highlight-layer {
      z-index: 1;
      pointer-events: none;
      background: var(--bg);
      color: var(--fg);
      overflow: hidden;
      transition: background 0.3s ease, color 0.3s ease;
    }

    #highlight-layer code {
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
      background: transparent !important;
      padding: 0 !important;
      display: block;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    /* Override highlight.js background */
    #highlight-layer code.hljs {
      background: transparent !important;
      padding: 0 !important;
    }

    /* Language indicator */
    #language-indicator {
      padding: 4px 10px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      background: var(--toggle-bg);
      border-radius: 4px;
      opacity: 0;
      transition: opacity 0.3s ease, background 0.2s ease;
      cursor: pointer;
      user-select: none;
    }

    #language-indicator:hover {
      background: var(--toggle-hover);
    }

    #language-indicator.visible {
      opacity: 0.7;
    }

    #language-indicator.visible:hover {
      opacity: 1;
    }

    /* Status bar container */
    #status-bar {
      position: fixed;
      bottom: 16px;
      right: 16px;
      display: flex;
      align-items: center;
      gap: 6px;
      z-index: 100;
    }

    /* Highlight toggle button */
    #highlight-toggle {
      padding: 4px 8px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      background: var(--toggle-bg);
      border: none;
      border-radius: 4px;
      opacity: 0;
      transition: opacity 0.3s ease, background 0.2s ease;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    #highlight-toggle:hover {
      background: var(--toggle-hover);
    }

    #highlight-toggle.visible {
      opacity: 0.7;
    }

    #highlight-toggle.visible:hover {
      opacity: 1;
    }

    #highlight-toggle svg {
      width: 12px;
      height: 12px;
      fill: currentColor;
    }

    #highlight-toggle.disabled {
      opacity: 0.5;
      position: relative;
    }


    #highlight-toggle.disabled.visible {
      opacity: 0.5;
    }

    #highlight-toggle.disabled.visible:hover {
      opacity: 0.7;
    }

    /* Ruff format button */
    #ruff-format {
      padding: 4px 10px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      background: var(--toggle-bg);
      border: none;
      border-radius: 4px;
      opacity: 0;
      display: none;
      transition: opacity 0.3s ease, background 0.2s ease;
      cursor: pointer;
      user-select: none;
      align-items: center;
      gap: 5px;
    }

    #ruff-format:hover {
      background: var(--toggle-hover);
    }

    #ruff-format.visible {
      opacity: 0.7;
      display: flex;
    }

    #ruff-format.visible:hover {
      opacity: 1;
    }

    #ruff-format.formatting {
      opacity: 0.5;
      pointer-events: none;
    }

    #ruff-format.unavailable {
      opacity: 0.4;
      cursor: default;
    }

    #ruff-format.unavailable:hover {
      background: var(--toggle-bg);
      opacity: 0.4;
    }

    /* SQL format button */
    #sql-format {
      padding: 4px 10px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      background: var(--toggle-bg);
      border: none;
      border-radius: 4px;
      opacity: 0;
      display: none;
      transition: opacity 0.3s ease, background 0.2s ease;
      cursor: pointer;
      user-select: none;
      align-items: center;
      gap: 5px;
    }

    #sql-format:hover {
      background: var(--toggle-hover);
    }

    #sql-format.visible {
      opacity: 0.7;
      display: flex;
    }

    #sql-format.visible:hover {
      opacity: 1;
    }

    #sql-format.formatting {
      opacity: 0.5;
      pointer-events: none;
    }

    #sql-format.unavailable {
      opacity: 0.4;
      cursor: default;
    }

    #sql-format.unavailable:hover {
      background: var(--toggle-bg);
      opacity: 0.4;
    }

    /* Prettier format button */
    #prettier-format {
      padding: 4px 10px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      background: var(--toggle-bg);
      border: none;
      border-radius: 4px;
      opacity: 0;
      display: none;
      transition: opacity 0.3s ease, background 0.2s ease;
      cursor: pointer;
      user-select: none;
      align-items: center;
      gap: 5px;
    }

    #prettier-format:hover {
      background: var(--toggle-hover);
    }

    #prettier-format.visible {
      opacity: 0.7;
      display: flex;
    }

    #prettier-format.visible:hover {
      opacity: 1;
    }

    #prettier-format.formatting {
      opacity: 0.5;
      pointer-events: none;
    }

    /* Formatter tooltip */
    .formatter-tooltip {
      position: fixed;
      bottom: 54px;
      right: 16px;
      background: var(--toggle-bg);
      border-radius: 6px;
      padding: 10px 14px;
      max-width: 280px;
      z-index: 102;
      opacity: 0;
      visibility: hidden;
      transform: translateY(8px);
      transition: opacity 0.15s ease, transform 0.15s ease, visibility 0.15s;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      line-height: 1.5;
    }

    .formatter-tooltip.open {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .formatter-tooltip-title {
      font-weight: 600;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .formatter-tooltip-title svg {
      width: 14px;
      height: 14px;
      fill: currentColor;
      opacity: 0.7;
    }

    .formatter-tooltip code {
      background: var(--toggle-hover);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
    }

    /* Language picker dropdown */
    #language-picker {
      position: fixed;
      bottom: 44px;
      right: 16px;
      background: var(--toggle-bg);
      border-radius: 6px;
      padding: 6px 0;
      max-height: 280px;
      overflow-y: auto;
      z-index: 101;
      opacity: 0;
      visibility: hidden;
      transform: translateY(8px);
      transition: opacity 0.15s ease, transform 0.15s ease, visibility 0.15s;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    #language-picker.open {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    #language-picker::-webkit-scrollbar {
      width: 6px;
    }

    #language-picker::-webkit-scrollbar-track {
      background: transparent;
    }

    #language-picker::-webkit-scrollbar-thumb {
      background: var(--fg);
      opacity: 0.3;
      border-radius: 3px;
    }

    .language-option {
      padding: 6px 14px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      cursor: pointer;
      transition: background 0.1s ease;
      white-space: nowrap;
    }

    .language-option:hover {
      background: var(--toggle-hover);
    }

    .language-option.selected {
      background: var(--toggle-hover);
      font-weight: 600;
    }

    .language-option.auto-detect {
      border-bottom: 1px solid var(--toggle-hover);
      margin-bottom: 4px;
      padding-bottom: 8px;
      font-style: italic;
      opacity: 0.8;
    }

    /* Settings button */
    #settings-btn {
      padding: 4px 8px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      background: var(--toggle-bg);
      border: none;
      border-radius: 4px;
      opacity: 0.7;
      transition: opacity 0.3s ease, background 0.2s ease;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    #settings-btn:hover {
      background: var(--toggle-hover);
      opacity: 1;
    }

    #settings-btn svg {
      width: 14px;
      height: 14px;
      fill: currentColor;
    }

    /* Settings menu */
    #settings-menu {
      position: fixed;
      bottom: 44px;
      right: 16px;
      background: var(--toggle-bg);
      border-radius: 6px;
      padding: 8px 0;
      min-width: 180px;
      z-index: 102;
      opacity: 0;
      visibility: hidden;
      transform: translateY(8px);
      transition: opacity 0.15s ease, transform 0.15s ease, visibility 0.15s;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    #settings-menu.open {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .settings-item {
      padding: 8px 14px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      cursor: pointer;
      transition: background 0.1s ease;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .settings-item:hover {
      background: var(--toggle-hover);
    }

    .settings-toggle {
      width: 32px;
      height: 18px;
      background: #444;
      border-radius: 9px;
      position: relative;
      transition: background 0.2s ease;
    }

    .settings-toggle.on {
      background: #4a9;
    }

    .settings-toggle::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 14px;
      height: 14px;
      background: var(--fg);
      border-radius: 50%;
      transition: transform 0.2s ease;
    }

    .settings-toggle.on::after {
      transform: translateX(14px);
    }

    /* Developer metrics panel */
    #dev-metrics {
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: var(--toggle-bg);
      border-radius: 6px;
      padding: 10px 14px;
      font-family: Monaco, Menlo, monospace;
      font-size: 10px;
      color: var(--fg);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s;
      z-index: 100;
      min-width: 140px;
    }

    #dev-metrics.visible {
      opacity: 0.85;
      visibility: visible;
    }

    #dev-metrics:hover {
      opacity: 1;
    }

    .dev-metric {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      padding: 2px 0;
    }

    .dev-metric-label {
      opacity: 0.6;
    }

    .dev-metric-value {
      font-weight: 600;
      text-align: right;
    }
  </style>
</head>
<body>
  <div id="app-container">
    <div id="tab-bar">
      <!-- Tabs will be generated dynamically -->
      <button id="add-tab" title="New tab (⌘T)">+</button>
    </div>
    <div id="editor-container">
      <pre id="highlight-layer"><code></code></pre>
      <textarea id="editor" autofocus spellcheck="false"></textarea>
    </div>
  </div>
  <div id="status-bar">
    <button id="ruff-format" title="Format with Ruff">
      <span>format w/ ruff</span>
    </button>
    <button id="sql-format" title="Format with sqlformat">
      <span>format w/ sqlformat</span>
    </button>
    <button id="prettier-format" title="Format with Prettier (⌘F)">
      <span>format w/ prettier</span>
    </button>
    <button id="highlight-toggle" title="Toggle syntax highlighting">
      <span>syntax on</span>
    </button>
    <div id="language-indicator" title="Change language">plaintext</div>
  </div>
  <div id="settings-menu">
    <div class="settings-item" id="dev-mode-toggle">
      <span>Developer Mode</span>
      <div class="settings-toggle"></div>
    </div>
  </div>
  <div id="language-picker"></div>
  <div id="formatter-tooltip" class="formatter-tooltip"></div>
  <div id="dev-metrics">
    <div class="dev-metric">
      <span class="dev-metric-label">language</span>
      <span class="dev-metric-value" id="metric-language">—</span>
    </div>
    <div class="dev-metric">
      <span class="dev-metric-label">relevance</span>
      <span class="dev-metric-value" id="metric-relevance">—</span>
    </div>
    <div class="dev-metric">
      <span class="dev-metric-label">per char</span>
      <span class="dev-metric-value" id="metric-per-char">—</span>
    </div>
    <div class="dev-metric">
      <span class="dev-metric-label">threshold</span>
      <span class="dev-metric-value" id="metric-threshold">—</span>
    </div>
    <div class="dev-metric">
      <span class="dev-metric-label">2nd best</span>
      <span class="dev-metric-value" id="metric-second-best">—</span>
    </div>
    <div class="dev-metric">
      <span class="dev-metric-label">2nd rel</span>
      <span class="dev-metric-value" id="metric-second-relevance">—</span>
    </div>
    <div class="dev-metric">
      <span class="dev-metric-label">2nd/char</span>
      <span class="dev-metric-value" id="metric-second-per-char">—</span>
    </div>
    <div class="dev-metric">
      <span class="dev-metric-label">illegal</span>
      <span class="dev-metric-value" id="metric-illegal">—</span>
    </div>
    <div class="dev-metric">
      <span class="dev-metric-label">chars</span>
      <span class="dev-metric-value" id="metric-chars">—</span>
    </div>
  </div>
  <script>
    const hljs = require('highlight.js');
    const { exec, spawn } = require('child_process');
    const { ipcRenderer } = require('electron');
    
    // ===== STORAGE KEYS =====
    const KEY = 'blackboard-content';
    const LANG_KEY = 'blackboard-language';
    const HIGHLIGHT_KEY = 'blackboard-highlighting';
    const TABS_KEY = 'blackboard-tabs';
    const ACTIVE_TAB_KEY = 'blackboard-active-tab';
    const DEV_MODE_KEY = 'blackboard-dev-mode';
    
    const tabBar = document.getElementById('tab-bar');
    const addTabBtn = document.getElementById('add-tab');
    
    // Load tabs from localStorage or create default
    function loadTabs() {
      const stored = localStorage.getItem(TABS_KEY);
      if (stored) {
        try {
          const parsed = JSON.parse(stored);
          // Clear old auto-generated single-letter names
          return parsed.map(tab => ({
            ...tab,
            name: (tab.name && tab.name.length > 1) ? tab.name : ''
          }));
        } catch (e) {
          return [{ id: 'tab-0', name: '', content: localStorage.getItem('blackboard-content') || '', language: null }];
        }
      }
      // Migrate existing content to first tab
      return [{ id: 'tab-0', name: '', content: localStorage.getItem('blackboard-content') || '', language: localStorage.getItem('blackboard-language') || null }];
    }
    
    // Save tabs to localStorage
    function saveTabs() {
      localStorage.setItem(TABS_KEY, JSON.stringify(tabs));
      localStorage.setItem(ACTIVE_TAB_KEY, activeTabId);
    }
    
    // Initialize tabs state
    let tabs = loadTabs();
    let activeTabId = localStorage.getItem(ACTIVE_TAB_KEY) || tabs[0]?.id || 'tab-0';
    
    // Ensure activeTabId exists in tabs
    if (!tabs.find(t => t.id === activeTabId)) {
      activeTabId = tabs[0]?.id || 'tab-0';
    }
    
    // Render the tab bar
    function renderTabs() {
      // Remove existing tab buttons (but keep the add button)
      const existingTabs = tabBar.querySelectorAll('.tab');
      existingTabs.forEach(t => t.remove());
      
      // Show/hide tab bar based on tab count or if any tab has a name
      const anyTabHasName = tabs.some(t => t.name && t.name.trim());
      if (tabs.length <= 1 && !anyTabHasName) {
        tabBar.classList.remove('visible');
      } else {
        tabBar.classList.add('visible');
      }
      
      // Create tab buttons
      tabs.forEach((tab, index) => {
        const tabEl = document.createElement('button');
        tabEl.className = 'tab' + (tab.id === activeTabId ? ' active' : '');
        tabEl.dataset.tabId = tab.id;
        
        // Add name span if tab has a name
        if (tab.name) {
          const nameSpan = document.createElement('span');
          nameSpan.className = 'tab-name';
          nameSpan.textContent = tab.name;
          tabEl.appendChild(nameSpan);
        }
        
        // Add close button (only if more than one tab)
        if (tabs.length > 1) {
          const closeBtn = document.createElement('span');
          closeBtn.className = 'tab-close';
          closeBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>';
          closeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            closeTab(tab.id);
          });
          tabEl.appendChild(closeBtn);
        }
        
        tabEl.addEventListener('click', () => switchToTab(tab.id));
        
        // Double-click to edit name (only on active tab)
        tabEl.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          if (tab.id === activeTabId) {
            startEditingTabName(tab.id, tabEl);
          }
        });
        
        // Insert before the add button
        tabBar.insertBefore(tabEl, addTabBtn);
      });
    }
    
    // Start editing a tab's name
    function startEditingTabName(tabId, tabEl) {
      const tab = tabs.find(t => t.id === tabId);
      if (!tab) return;
      
      // Remove existing content
      const existingName = tabEl.querySelector('.tab-name');
      if (existingName) existingName.remove();
      
      // Create input
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'tab-name-input';
      input.value = tab.name || '';
      input.placeholder = '...';
      
      // Insert at the beginning (before close button)
      tabEl.insertBefore(input, tabEl.firstChild);
      input.focus();
      input.select();
      
      // Save on blur or enter
      const saveAndClose = () => {
        tab.name = input.value.trim();
        saveTabs();
        renderTabs();
        editor.focus();
      };
      
      input.addEventListener('blur', saveAndClose);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          saveAndClose();
        }
        if (e.key === 'Escape') {
          e.preventDefault();
          renderTabs();
          editor.focus();
        }
      });
      
      // Prevent click from bubbling
      input.addEventListener('click', (e) => e.stopPropagation());
    }
    
    // Get active tab data
    function getActiveTab() {
      return tabs.find(t => t.id === activeTabId) || tabs[0];
    }
    
    // Switch to a tab
    function switchToTab(tabId) {
      // Don't do anything if already on this tab (allows double-click to work)
      if (tabId === activeTabId) return;
      
      // Save current tab content
      const currentTab = getActiveTab();
      if (currentTab) {
        currentTab.content = editor.value;
        currentTab.language = manualLanguage;
      }
      
      // Switch to new tab
      activeTabId = tabId;
      const newTab = getActiveTab();
      
      if (newTab) {
        editor.value = newTab.content || '';
        manualLanguage = newTab.language;
        if (manualLanguage) {
          localStorage.setItem(LANG_KEY, manualLanguage);
        } else {
          localStorage.removeItem(LANG_KEY);
        }
      }
      
      saveTabs();
      renderTabs();
      applyHighlighting();
      editor.focus();
    }
    
    // Create a new tab
    function createNewTab() {
      // Save current tab content first
      const currentTab = getActiveTab();
      if (currentTab) {
        currentTab.content = editor.value;
        currentTab.language = manualLanguage;
      }
      
      // Create new tab
      const newId = 'tab-' + Date.now();
      tabs.push({ id: newId, name: '', content: '', language: null });
      activeTabId = newId;
      
      // Clear editor
      editor.value = '';
      manualLanguage = null;
      localStorage.removeItem(LANG_KEY);
      
      saveTabs();
      renderTabs();
      applyHighlighting();
      editor.focus();
    }
    
    // Close a tab
    function closeTab(tabId) {
      if (tabs.length <= 1) return; // Don't close last tab
      
      const index = tabs.findIndex(t => t.id === tabId);
      if (index === -1) return;
      
      tabs.splice(index, 1);
      
      // If we closed the active tab, switch to another
      if (tabId === activeTabId) {
        // Switch to the tab at the same index, or the last tab if we closed the last one
        const newIndex = Math.min(index, tabs.length - 1);
        activeTabId = tabs[newIndex].id;
        const newTab = tabs[newIndex];
        editor.value = newTab.content || '';
        manualLanguage = newTab.language;
        if (manualLanguage) {
          localStorage.setItem(LANG_KEY, manualLanguage);
        } else {
          localStorage.removeItem(LANG_KEY);
        }
        applyHighlighting();
      }
      
      saveTabs();
      renderTabs();
      editor.focus();
    }
    
    // Add tab button handler
    addTabBtn.addEventListener('click', createNewTab);
    
    // Keyboard shortcuts for tabs
    document.addEventListener('keydown', (e) => {
      // Cmd+T to create new tab
      if ((e.metaKey || e.ctrlKey) && e.key === 't') {
        e.preventDefault();
        createNewTab();
      }
      // Cmd+W to close current tab
      if ((e.metaKey || e.ctrlKey) && e.key === 'w') {
        e.preventDefault();
        if (tabs.length > 1) {
          closeTab(activeTabId);
        }
      }
      // Cmd+Shift+] to go to next tab
      if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === ']') {
        e.preventDefault();
        const currentIndex = tabs.findIndex(t => t.id === activeTabId);
        const nextIndex = (currentIndex + 1) % tabs.length;
        switchToTab(tabs[nextIndex].id);
      }
      // Cmd+Shift+[ to go to previous tab
      if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === '[') {
        e.preventDefault();
        const currentIndex = tabs.findIndex(t => t.id === activeTabId);
        const prevIndex = (currentIndex - 1 + tabs.length) % tabs.length;
        switchToTab(tabs[prevIndex].id);
      }
      // Cmd+D to toggle developer mode
      if ((e.metaKey || e.ctrlKey) && e.key === 'd') {
        e.preventDefault();
        toggleDevMode();
      }
    });
    
    // ===== END TAB MANAGEMENT =====
    
    // Limit auto-detection to these languages only
    hljs.configure({
      languages: [
        'javascript',
        'typescript',
        'python',
        'html',
        'css',
        'json',
        'bash',
        'shell',
        'sql',
        'go',
        'rust',
        'java',
        'c',
        'cpp',
        'ruby',
        'php',
        'swift',
        'kotlin',
        'yaml',
        'markdown',
        'scala',
        'haskell',
        'lua',
        'r',
        'perl'
      ]
    });
    
    const editor = document.getElementById('editor');
    const highlightLayer = document.getElementById('highlight-layer').querySelector('code');
    const languageIndicator = document.getElementById('language-indicator');
    const languagePicker = document.getElementById('language-picker');
    const highlightToggle = document.getElementById('highlight-toggle');

    // Highlighting enabled state
    let highlightingEnabled = localStorage.getItem(HIGHLIGHT_KEY) !== 'false';

    // Minimum thresholds to apply syntax highlighting
    const RELEVANCE_THRESHOLD = 5;
    const RELEVANCE_PER_CHAR_THRESHOLD = 0.02;

    // Check if detected language meets confidence threshold
    function meetsConfidenceThreshold(relevance, text) {
      const charCount = text.length;
      if (charCount === 0) return false;
      const relevancePerChar = relevance / charCount;
      return relevance >= RELEVANCE_THRESHOLD && relevancePerChar > RELEVANCE_PER_CHAR_THRESHOLD;
    }

    // Developer mode state
    let developerMode = localStorage.getItem(DEV_MODE_KEY) === 'true';
    const devMetrics = document.getElementById('dev-metrics');
    const metricLanguage = document.getElementById('metric-language');
    const metricRelevance = document.getElementById('metric-relevance');
    const metricPerChar = document.getElementById('metric-per-char');
    const metricThreshold = document.getElementById('metric-threshold');
    const metricSecondBest = document.getElementById('metric-second-best');
    const metricSecondRelevance = document.getElementById('metric-second-relevance');
    const metricSecondPerChar = document.getElementById('metric-second-per-char');
    const metricIllegal = document.getElementById('metric-illegal');
    const metricChars = document.getElementById('metric-chars');
    
    // Current metrics from last highlight result
    let lastMetrics = {
      language: null,
      relevance: null,
      relevancePerChar: null,
      meetsThreshold: null,
      secondBest: null,
      secondRelevance: null,
      secondPerChar: null,
      illegal: null,
      charCount: null
    };

    // Update developer metrics display
    function updateDevMetrics(result, text) {
      const charCount = text.length;
      const relevance = result.relevance || 0;
      const relevancePerChar = charCount > 0 ? relevance / charCount : 0;
      const meetsThreshold = relevancePerChar >= RELEVANCE_PER_CHAR_THRESHOLD;
      const secondRelevance = result.secondBest?.relevance || null;
      const secondPerChar = (secondRelevance !== null && charCount > 0) ? secondRelevance / charCount : null;
      
      lastMetrics = {
        language: result.language || null,
        relevance: relevance,
        relevancePerChar: relevancePerChar,
        meetsThreshold: meetsThreshold,
        secondBest: result.secondBest?.language || null,
        secondRelevance: secondRelevance,
        secondPerChar: secondPerChar,
        illegal: result.illegal || false,
        charCount: charCount
      };
      
      if (developerMode) {
        refreshDevMetricsDisplay();
      }
    }
    
    // Refresh the dev metrics display from lastMetrics
    function refreshDevMetricsDisplay() {
      metricLanguage.textContent = lastMetrics.language || '—';
      metricRelevance.textContent = lastMetrics.relevance !== null ? lastMetrics.relevance.toFixed(1) : '—';
      metricPerChar.textContent = lastMetrics.relevancePerChar !== null ? lastMetrics.relevancePerChar.toFixed(4) : '—';
      metricThreshold.textContent = lastMetrics.meetsThreshold !== null ? (lastMetrics.meetsThreshold ? '✓ pass' : '✗ fail') : '—';
      metricSecondBest.textContent = lastMetrics.secondBest || '—';
      metricSecondRelevance.textContent = lastMetrics.secondRelevance !== null ? lastMetrics.secondRelevance.toFixed(1) : '—';
      metricSecondPerChar.textContent = lastMetrics.secondPerChar !== null ? lastMetrics.secondPerChar.toFixed(4) : '—';
      metricIllegal.textContent = lastMetrics.illegal ? 'yes' : 'no';
      metricChars.textContent = lastMetrics.charCount !== null ? lastMetrics.charCount.toLocaleString() : '—';
    }

    // Settings menu elements
    const settingsMenu = document.getElementById('settings-menu');
    const devModeToggle = document.getElementById('dev-mode-toggle');
    const devModeToggleSwitch = devModeToggle.querySelector('.settings-toggle');

    // Update developer mode UI
    function updateDevModeUI() {
      if (developerMode) {
        devModeToggleSwitch.classList.add('on');
        devMetrics.classList.add('visible');
        // Refresh metrics display
        refreshDevMetricsDisplay();
      } else {
        devModeToggleSwitch.classList.remove('on');
        devMetrics.classList.remove('visible');
      }
    }

    // Toggle developer mode
    function toggleDevMode() {
      developerMode = !developerMode;
      localStorage.setItem(DEV_MODE_KEY, developerMode ? 'true' : 'false');
      updateDevModeUI();
    }

    // Dev mode toggle click handler
    devModeToggle.addEventListener('click', () => {
      toggleDevMode();
    });

    // Close settings menu when clicking outside
    document.addEventListener('click', (e) => {
      if (!settingsMenu.contains(e.target)) {
        settingsMenu.classList.remove('open');
      }
    });

    // Listen for settings menu command from main process (Blackboard > Settings)
    ipcRenderer.on('open-settings', () => {
      settingsMenu.classList.toggle('open');
    });

    // Initialize developer mode UI
    updateDevModeUI();

    // Available languages for the picker (alphabetical)
    const AVAILABLE_LANGUAGES = [
      'bash',
      'c',
      'cpp',
      'css',
      'go',
      'haskell',
      'html',
      'java',
      'javascript',
      'json',
      'kotlin',
      'lua',
      'markdown',
      'perl',
      'php',
      'plaintext',
      'python',
      'r',
      'ruby',
      'rust',
      'scala',
      'shell',
      'sql',
      'swift',
      'typescript',
      'yaml'
    ];

    // Manual language override (null = auto-detect)
    let manualLanguage = localStorage.getItem(LANG_KEY) || null;

    // Ruff availability
    let ruffAvailable = false;
    const ruffFormatBtn = document.getElementById('ruff-format');

    // Check if ruff is available on system
    function checkRuffAvailable() {
      // Try common paths including user's local bin directories
      const pathsToTry = [
        process.env.HOME + '/.local/bin',
        process.env.HOME + '/.cargo/bin',
        '/usr/local/bin',
        '/opt/homebrew/bin'
      ].join(':') + ':' + (process.env.PATH || '');

      exec('ruff --version', { env: { ...process.env, PATH: pathsToTry } }, (error, stdout, stderr) => {
        ruffAvailable = !error;
        updateRuffButton();
      });
    }

    // Update ruff button visibility
    function updateRuffButton() {
      const isPython = currentLanguage === 'python' || manualLanguage === 'python';
      if (isPython && editor.value.trim()) {
        ruffFormatBtn.classList.add('visible');
        if (ruffAvailable) {
          ruffFormatBtn.classList.remove('unavailable');
          ruffFormatBtn.title = 'Format with Ruff (⌘F)';
        } else {
          ruffFormatBtn.classList.add('unavailable');
          ruffFormatBtn.title = 'Ruff not installed - click for info';
        }
      } else {
        ruffFormatBtn.classList.remove('visible');
        ruffFormatBtn.classList.remove('unavailable');
      }
    }

    // Format code with ruff
    function formatWithRuff() {
      if (!ruffAvailable) return;
      
      const code = editor.value;
      if (!code.trim()) return;

      ruffFormatBtn.classList.add('formatting');

      // Build PATH with common locations
      const pathsToTry = [
        process.env.HOME + '/.local/bin',
        process.env.HOME + '/.cargo/bin',
        '/usr/local/bin',
        '/opt/homebrew/bin'
      ].join(':') + ':' + (process.env.PATH || '');

      const ruff = spawn('ruff', ['format', '-'], {
        env: { ...process.env, PATH: pathsToTry }
      });

      let formattedCode = '';
      let errorOutput = '';

      ruff.stdout.on('data', (data) => {
        formattedCode += data.toString();
      });

      ruff.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      ruff.on('close', (exitCode) => {
        ruffFormatBtn.classList.remove('formatting');

        if (exitCode === 0 && formattedCode) {
          // Preserve cursor position roughly
          const cursorPos = editor.selectionStart;
          const ratio = cursorPos / code.length;
          
          editor.value = formattedCode;
          localStorage.setItem(KEY, formattedCode);
          
          // Restore cursor position proportionally
          const newPos = Math.round(ratio * formattedCode.length);
          editor.setSelectionRange(newPos, newPos);
          
          applyHighlighting();
        }
      });

      ruff.stdin.write(code);
      ruff.stdin.end();
    }

    // Ruff button click handler
    ruffFormatBtn.addEventListener('click', () => {
      if (ruffAvailable) {
        formatWithRuff();
      } else {
        showFormatterTooltip('ruff', 'uv tool install ruff');
      }
    });

    // Check for ruff on startup
    checkRuffAvailable();

    // sqlformat availability
    let sqlformatAvailable = false;
    const sqlFormatBtn = document.getElementById('sql-format');

    // Formatter tooltip
    const formatterTooltip = document.getElementById('formatter-tooltip');
    let tooltipTimeout = null;

    function showFormatterTooltip(formatter, installCmd) {
      clearTimeout(tooltipTimeout);
      formatterTooltip.innerHTML = `
        <div class="formatter-tooltip-title">
          <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>
          ${formatter} not installed
        </div>
        <div>To enable formatting, run:</div>
        <div style="margin-top: 6px;"><code>${installCmd}</code></div>
      `;
      formatterTooltip.classList.add('open');
      
      // Auto-hide after 5 seconds
      tooltipTimeout = setTimeout(() => {
        formatterTooltip.classList.remove('open');
      }, 5000);
    }

    function hideFormatterTooltip() {
      clearTimeout(tooltipTimeout);
      formatterTooltip.classList.remove('open');
    }

    // Check if sqlformat is available on system
    function checkSqlformatAvailable() {
      const pathsToTry = [
        process.env.HOME + '/.local/bin',
        process.env.HOME + '/.pyenv/shims',
        '/usr/local/bin',
        '/opt/homebrew/bin'
      ].join(':') + ':' + (process.env.PATH || '');

      exec('sqlformat --version', { env: { ...process.env, PATH: pathsToTry } }, (error, stdout, stderr) => {
        sqlformatAvailable = !error;
        updateSqlFormatButton();
      });
    }

    // Update sqlformat button visibility
    function updateSqlFormatButton() {
      const isSQL = currentLanguage === 'sql' || manualLanguage === 'sql';
      if (isSQL && editor.value.trim()) {
        sqlFormatBtn.classList.add('visible');
        if (sqlformatAvailable) {
          sqlFormatBtn.classList.remove('unavailable');
          sqlFormatBtn.title = 'Format with sqlformat (⌘F)';
        } else {
          sqlFormatBtn.classList.add('unavailable');
          sqlFormatBtn.title = 'sqlformat not installed - click for info';
        }
      } else {
        sqlFormatBtn.classList.remove('visible');
        sqlFormatBtn.classList.remove('unavailable');
      }
    }

    // Format code with sqlformat
    function formatWithSqlformat() {
      if (!sqlformatAvailable) return;
      
      const code = editor.value;
      if (!code.trim()) return;

      sqlFormatBtn.classList.add('formatting');

      const pathsToTry = [
        process.env.HOME + '/.local/bin',
        process.env.HOME + '/.pyenv/shims',
        '/usr/local/bin',
        '/opt/homebrew/bin'
      ].join(':') + ':' + (process.env.PATH || '');

      // sqlformat options: -r for reindent, -k upper for uppercase keywords
      const sqlformat = spawn('sqlformat', ['-r', '-k', 'upper', '-'], {
        env: { ...process.env, PATH: pathsToTry }
      });

      let formattedCode = '';
      let errorOutput = '';

      sqlformat.stdout.on('data', (data) => {
        formattedCode += data.toString();
      });

      sqlformat.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      sqlformat.on('close', (exitCode) => {
        sqlFormatBtn.classList.remove('formatting');

        if (exitCode === 0 && formattedCode) {
          const cursorPos = editor.selectionStart;
          const ratio = cursorPos / code.length;
          
          editor.value = formattedCode;
          localStorage.setItem(KEY, formattedCode);
          
          const newPos = Math.round(ratio * formattedCode.length);
          editor.setSelectionRange(newPos, newPos);
          
          applyHighlighting();
        }
      });

      sqlformat.stdin.write(code);
      sqlformat.stdin.end();
    }

    // sqlformat button click handler
    sqlFormatBtn.addEventListener('click', () => {
      if (sqlformatAvailable) {
        formatWithSqlformat();
      } else {
        showFormatterTooltip('sqlformat', 'uv tool install --from sqlparse sqlformat');
      }
    });

    // Check for sqlformat on startup
    checkSqlformatAvailable();

    // Prettier (bundled with app - always available)
    // Lazy load to avoid blocking startup
    let prettierModule = null;
    let prettierPlugins = {};
    
    const prettierFormatBtn = document.getElementById('prettier-format');

    // Languages supported by Prettier and their parser names + plugin names
    const PRETTIER_CONFIG = {
      'javascript': { parser: 'babel', pluginNames: ['babel', 'estree'] },
      'typescript': { parser: 'typescript', pluginNames: ['typescript', 'estree'] },
      'json': { parser: 'json', pluginNames: ['babel', 'estree'] },
      'html': { parser: 'html', pluginNames: ['html'] },
      'css': { parser: 'css', pluginNames: ['postcss'] },
      'markdown': { parser: 'markdown', pluginNames: ['markdown'] },
      'yaml': { parser: 'yaml', pluginNames: ['yaml'] }
    };

    // Lazy load prettier and required plugins
    function getPrettierPlugins(pluginNames) {
      if (!prettierModule) {
        prettierModule = require('prettier/standalone');
      }
      const plugins = [];
      for (const name of pluginNames) {
        if (!prettierPlugins[name]) {
          prettierPlugins[name] = require(`prettier/plugins/${name}`);
        }
        plugins.push(prettierPlugins[name]);
      }
      return plugins;
    }

    // Update prettier button visibility
    function updatePrettierButton() {
      const lang = manualLanguage || currentLanguage;
      const config = PRETTIER_CONFIG[lang];
      
      if (config && editor.value.trim()) {
        prettierFormatBtn.classList.add('visible');
        prettierFormatBtn.title = 'Format with Prettier (⌘F)';
      } else {
        prettierFormatBtn.classList.remove('visible');
      }
    }

    // Format code with Prettier
    async function formatWithPrettier() {
      const code = editor.value;
      if (!code.trim()) return;

      const lang = manualLanguage || currentLanguage;
      const config = PRETTIER_CONFIG[lang];
      if (!config) return;

      prettierFormatBtn.classList.add('formatting');

      try {
        const plugins = getPrettierPlugins(config.pluginNames);
        const formattedCode = await prettierModule.format(code, {
          parser: config.parser,
          plugins: plugins,
          tabWidth: 2,
          singleQuote: true,
          trailingComma: 'es5',
          printWidth: 100
        });

        // Preserve cursor position roughly
        const cursorPos = editor.selectionStart;
        const ratio = cursorPos / code.length;

        editor.value = formattedCode;
        localStorage.setItem(KEY, formattedCode);

        // Restore cursor position proportionally
        const newPos = Math.round(ratio * formattedCode.length);
        editor.setSelectionRange(newPos, newPos);

        applyHighlighting();
      } catch (err) {
        // Formatting failed (likely syntax error) - just ignore
        console.error('Prettier error:', err);
      } finally {
        prettierFormatBtn.classList.remove('formatting');
      }
    }

    // Prettier button click handler
    prettierFormatBtn.addEventListener('click', formatWithPrettier);

    // Build the language picker dropdown
    function buildLanguagePicker() {
      languagePicker.innerHTML = '';
      
      // Auto-detect option
      const autoOption = document.createElement('div');
      autoOption.className = 'language-option auto-detect' + (manualLanguage === null ? ' selected' : '');
      autoOption.textContent = 'Auto-detect';
      autoOption.addEventListener('click', () => selectLanguage(null));
      languagePicker.appendChild(autoOption);

      // Language options
      AVAILABLE_LANGUAGES.forEach(lang => {
        const option = document.createElement('div');
        option.className = 'language-option' + (manualLanguage === lang ? ' selected' : '');
        option.textContent = lang;
        option.addEventListener('click', () => selectLanguage(lang));
        languagePicker.appendChild(option);
      });
    }

    // Select a language
    function selectLanguage(lang) {
      manualLanguage = lang;
      if (lang) {
        localStorage.setItem(LANG_KEY, lang);
      } else {
        localStorage.removeItem(LANG_KEY);
      }
      // Save language to current tab
      const currentTab = getActiveTab();
      if (currentTab) {
        currentTab.language = lang;
        saveTabs();
      }
      closePicker();
      applyHighlighting();
    }

    // Toggle picker visibility
    function togglePicker() {
      const isOpen = languagePicker.classList.contains('open');
      if (isOpen) {
        closePicker();
      } else {
        buildLanguagePicker();
        languagePicker.classList.add('open');
      }
    }

    function closePicker() {
      languagePicker.classList.remove('open');
    }

    // Language indicator click handler
    languageIndicator.addEventListener('click', (e) => {
      e.stopPropagation();
      togglePicker();
    });

    // Close picker when clicking outside
    document.addEventListener('click', (e) => {
      if (!languagePicker.contains(e.target) && e.target !== languageIndicator) {
        closePicker();
      }
      // Close formatter tooltip when clicking outside
      if (!formatterTooltip.contains(e.target) && 
          !ruffFormatBtn.contains(e.target) && 
          !sqlFormatBtn.contains(e.target)) {
        hideFormatterTooltip();
      }
    });

    // Close picker and tooltip on escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closePicker();
        hideFormatterTooltip();
      }
    });

    // Cmd+F to format (if a formatter is available)
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'f') {
        const lang = manualLanguage || currentLanguage;
        
        // Check if we have an available formatter for this language
        if (lang === 'python' && ruffAvailable) {
          e.preventDefault();
          formatWithRuff();
        } else if (lang === 'sql' && sqlformatAvailable) {
          e.preventDefault();
          formatWithSqlformat();
        } else if (PRETTIER_CONFIG[lang]) {
          e.preventDefault();
          formatWithPrettier();
        }
        // Otherwise, let default behavior (browser find) happen
      }
    });

    // Escape HTML to prevent XSS and display issues
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Debounce function for performance
    function debounce(fn, delay) {
      let timeout;
      return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    // Track current detected language
    let currentLanguage = null;

    // Update highlight toggle button state
    function updateHighlightToggle() {
      const span = highlightToggle.querySelector('span');
      if (highlightingEnabled) {
        highlightToggle.classList.remove('disabled');
        highlightToggle.title = 'Disable syntax highlighting';
        span.textContent = 'syntax on';
      } else {
        highlightToggle.classList.add('disabled');
        highlightToggle.title = 'Enable syntax highlighting';
        span.textContent = 'syntax off';
      }
    }

    // Toggle syntax highlighting
    function toggleHighlighting() {
      highlightingEnabled = !highlightingEnabled;
      localStorage.setItem(HIGHLIGHT_KEY, highlightingEnabled ? 'true' : 'false');
      updateHighlightToggle();
      applyHighlighting();
    }

    // Highlight toggle click handler
    highlightToggle.addEventListener('click', toggleHighlighting);

    // Apply highlighting based on current language (manual or detected)
    function applyHighlighting() {
      const text = editor.value;
      
      if (!text.trim()) {
        highlightLayer.innerHTML = '';
        highlightLayer.className = '';
        currentLanguage = null;
        updateIndicator('plaintext');
        return;
      }

      // If highlighting is disabled, show plain text
      if (!highlightingEnabled) {
        highlightLayer.innerHTML = escapeHtml(text);
        highlightLayer.className = '';
        // Still detect language for indicator but don't highlight
        if (manualLanguage) {
          updateIndicator(manualLanguage);
        } else {
          try {
            const result = hljs.highlightAuto(text);
            if (meetsConfidenceThreshold(result.relevance, text) && result.language) {
              currentLanguage = result.language;
              updateIndicator(result.language);
            } else {
              currentLanguage = null;
              updateIndicator('plaintext');
            }
          } catch (e) {
            currentLanguage = null;
            updateIndicator('plaintext');
          }
        }
        return;
      }

      if (manualLanguage) {
        // Use manually selected language
        try {
          const result = hljs.highlight(text, { language: manualLanguage });
          currentLanguage = manualLanguage;
          highlightLayer.innerHTML = result.value;
          highlightLayer.className = `hljs language-${manualLanguage}`;
          updateIndicator(manualLanguage);
        } catch (e) {
          highlightLayer.innerHTML = escapeHtml(text);
          highlightLayer.className = '';
          updateIndicator('plaintext');
        }
      } else {
        // Auto-detect
        detectAndHighlight();
      }
    }

    // Update the language indicator display
    function updateIndicator(lang) {
      // Show "auto: LANGUAGE" when in auto-detect mode and a language was detected
      if (manualLanguage === null && lang !== 'plaintext') {
        languageIndicator.textContent = 'auto: ' + lang;
      } else {
        languageIndicator.textContent = lang;
      }
      languageIndicator.classList.add('visible');
      
      if (lang === 'plaintext') {
        highlightToggle.classList.remove('visible');
      } else {
        highlightToggle.classList.add('visible');
      }
      
      // darkToggle.classList.add('visible');
      updateRuffButton();
      updateSqlFormatButton();
      updatePrettierButton();
    }

    // Immediately update display (plain text or re-apply current highlighting)
    function updateDisplayImmediate() {
      const text = editor.value;
      
      if (!text.trim()) {
        highlightLayer.innerHTML = '';
        highlightLayer.className = '';
        currentLanguage = null;
        updateIndicator('plaintext');
        return;
      }

      // If highlighting is disabled, show plain text
      if (!highlightingEnabled) {
        highlightLayer.innerHTML = escapeHtml(text);
        return;
      }

      const langToUse = manualLanguage || currentLanguage;
      if (langToUse) {
        // Re-apply known language highlighting immediately
        try {
          const result = hljs.highlight(text, { language: langToUse });
          highlightLayer.innerHTML = result.value;
        } catch (e) {
          highlightLayer.innerHTML = escapeHtml(text);
        }
      } else {
        // No language detected yet, show plain text
        highlightLayer.innerHTML = escapeHtml(text);
      }
    }

    // Expensive language detection (debounced)
    function detectAndHighlight() {
      const text = editor.value;
      
      if (!text.trim()) {
        currentLanguage = null;
        updateIndicator('plaintext');
        updateDevMetrics({}, '');
        return;
      }

      // If manual language is set, show metrics for that language
      if (manualLanguage) {
        try {
          const result = hljs.highlight(text, { language: manualLanguage });
          // For manual highlighting, add language to result since it's not auto-detected
          result.language = manualLanguage;
          updateDevMetrics(result, text);
        } catch (e) {
          updateDevMetrics({ language: manualLanguage }, text);
        }
        return;
      }

      try {
        const result = hljs.highlightAuto(text);
        updateDevMetrics(result, text);
        
        if (meetsConfidenceThreshold(result.relevance, text) && result.language) {
          currentLanguage = result.language;
          highlightLayer.innerHTML = result.value;
          highlightLayer.className = `hljs language-${result.language}`;
          updateIndicator(result.language);
        } else {
          currentLanguage = null;
          highlightLayer.innerHTML = escapeHtml(text);
          highlightLayer.className = '';
          updateIndicator('plaintext');
        }
      } catch (e) {
        currentLanguage = null;
        highlightLayer.innerHTML = escapeHtml(text);
        highlightLayer.className = '';
        updateIndicator('plaintext');
        updateDevMetrics({}, text);
      }
    }

    // Sync scroll between editor and highlight layer
    function syncScroll() {
      const pre = document.getElementById('highlight-layer');
      pre.scrollTop = editor.scrollTop;
      pre.scrollLeft = editor.scrollLeft;
    }

    // Debounced language detection
    const debouncedDetect = debounce(detectAndHighlight, 300);

    // Initialize from active tab
    const initialTab = getActiveTab();
    if (initialTab) {
      editor.value = initialTab.content || '';
      manualLanguage = initialTab.language;
      if (manualLanguage) {
        localStorage.setItem(LANG_KEY, manualLanguage);
      }
    }
    
    updateHighlightToggle();
    renderTabs();
    applyHighlighting();

    editor.addEventListener('input', () => {
      // Save to current tab
      const currentTab = getActiveTab();
      if (currentTab) {
        currentTab.content = editor.value;
        saveTabs();
      }
      // Also save to legacy key for compatibility with CLI
      localStorage.setItem(KEY, editor.value);
      updateDisplayImmediate();  // Instant text update
      debouncedDetect();         // Delayed language detection
    });

    editor.addEventListener('scroll', syncScroll);
  </script>
</body>
</html>
