<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Blackboard</title>
  <link rel="stylesheet" href="./node_modules/highlight.js/styles/github-dark.css">
  <style>
    :root {
      --bg: #0d0d0d;
      --fg: #e0e0e0;
      --toggle-bg: #2a2a2a;
      --toggle-hover: #3a3a3a;
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: var(--bg);
      transition: background 0.3s ease;
    }

    #editor-container {
      position: relative;
      width: 100%;
      height: 100%;
    }

    #editor, #highlight-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      padding: 12px;
      font-family: Monaco, Menlo, monospace;
      font-size: 13px;
      line-height: 1.7;
      border: none;
      margin: 0;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    #editor {
      outline: none;
      resize: none;
      background: transparent;
      color: transparent;
      caret-color: var(--fg);
      z-index: 2;
      -webkit-text-fill-color: transparent;
    }

    #editor::selection {
      background: rgba(100, 100, 255, 0.3);
    }

    #editor::-moz-selection {
      background: rgba(100, 100, 255, 0.3);
    }

    #highlight-layer {
      z-index: 1;
      pointer-events: none;
      background: var(--bg);
      color: var(--fg);
      overflow: hidden;
      transition: background 0.3s ease, color 0.3s ease;
    }

    #highlight-layer code {
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
      background: transparent !important;
      padding: 0 !important;
      display: block;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    /* Override highlight.js background */
    #highlight-layer code.hljs {
      background: transparent !important;
      padding: 0 !important;
    }

    /* Language indicator */
    #language-indicator {
      padding: 4px 10px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      background: var(--toggle-bg);
      border-radius: 4px;
      opacity: 0;
      transition: opacity 0.3s ease, background 0.2s ease;
      cursor: pointer;
      user-select: none;
    }

    #language-indicator:hover {
      background: var(--toggle-hover);
    }

    #language-indicator.visible {
      opacity: 0.7;
    }

    #language-indicator.visible:hover {
      opacity: 1;
    }

    /* Status bar container */
    #status-bar {
      position: fixed;
      bottom: 16px;
      right: 16px;
      display: flex;
      align-items: center;
      gap: 6px;
      z-index: 100;
    }

    /* Highlight toggle button */
    #highlight-toggle {
      padding: 4px 8px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      background: var(--toggle-bg);
      border: none;
      border-radius: 4px;
      opacity: 0;
      transition: opacity 0.3s ease, background 0.2s ease;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    #highlight-toggle:hover {
      background: var(--toggle-hover);
    }

    #highlight-toggle.visible {
      opacity: 0.7;
    }

    #highlight-toggle.visible:hover {
      opacity: 1;
    }

    #highlight-toggle svg {
      width: 12px;
      height: 12px;
      fill: currentColor;
    }

    #highlight-toggle.disabled {
      opacity: 0.5;
      position: relative;
    }


    #highlight-toggle.disabled.visible {
      opacity: 0.5;
    }

    #highlight-toggle.disabled.visible:hover {
      opacity: 0.7;
    }

    /* Ruff format button */
    #ruff-format {
      padding: 4px 10px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      background: var(--toggle-bg);
      border: none;
      border-radius: 4px;
      opacity: 0;
      display: none;
      transition: opacity 0.3s ease, background 0.2s ease;
      cursor: pointer;
      user-select: none;
      align-items: center;
      gap: 5px;
    }

    #ruff-format:hover {
      background: var(--toggle-hover);
    }

    #ruff-format.visible {
      opacity: 0.7;
      display: flex;
    }

    #ruff-format.visible:hover {
      opacity: 1;
    }

    #ruff-format.formatting {
      opacity: 0.5;
      pointer-events: none;
    }

    #ruff-format.unavailable {
      opacity: 0.4;
      cursor: default;
    }

    #ruff-format.unavailable:hover {
      background: var(--toggle-bg);
      opacity: 0.4;
    }

    /* SQL format button */
    #sql-format {
      padding: 4px 10px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      background: var(--toggle-bg);
      border: none;
      border-radius: 4px;
      opacity: 0;
      display: none;
      transition: opacity 0.3s ease, background 0.2s ease;
      cursor: pointer;
      user-select: none;
      align-items: center;
      gap: 5px;
    }

    #sql-format:hover {
      background: var(--toggle-hover);
    }

    #sql-format.visible {
      opacity: 0.7;
      display: flex;
    }

    #sql-format.visible:hover {
      opacity: 1;
    }

    #sql-format.formatting {
      opacity: 0.5;
      pointer-events: none;
    }

    #sql-format.unavailable {
      opacity: 0.4;
      cursor: default;
    }

    #sql-format.unavailable:hover {
      background: var(--toggle-bg);
      opacity: 0.4;
    }

    /* Prettier format button */
    #prettier-format {
      padding: 4px 10px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      background: var(--toggle-bg);
      border: none;
      border-radius: 4px;
      opacity: 0;
      display: none;
      transition: opacity 0.3s ease, background 0.2s ease;
      cursor: pointer;
      user-select: none;
      align-items: center;
      gap: 5px;
    }

    #prettier-format:hover {
      background: var(--toggle-hover);
    }

    #prettier-format.visible {
      opacity: 0.7;
      display: flex;
    }

    #prettier-format.visible:hover {
      opacity: 1;
    }

    #prettier-format.formatting {
      opacity: 0.5;
      pointer-events: none;
    }

    /* Formatter tooltip */
    .formatter-tooltip {
      position: fixed;
      bottom: 54px;
      right: 16px;
      background: var(--toggle-bg);
      border-radius: 6px;
      padding: 10px 14px;
      max-width: 280px;
      z-index: 102;
      opacity: 0;
      visibility: hidden;
      transform: translateY(8px);
      transition: opacity 0.15s ease, transform 0.15s ease, visibility 0.15s;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      line-height: 1.5;
    }

    .formatter-tooltip.open {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .formatter-tooltip-title {
      font-weight: 600;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .formatter-tooltip-title svg {
      width: 14px;
      height: 14px;
      fill: currentColor;
      opacity: 0.7;
    }

    .formatter-tooltip code {
      background: var(--toggle-hover);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
    }

    /* Language picker dropdown */
    #language-picker {
      position: fixed;
      bottom: 44px;
      right: 16px;
      background: var(--toggle-bg);
      border-radius: 6px;
      padding: 6px 0;
      max-height: 280px;
      overflow-y: auto;
      z-index: 101;
      opacity: 0;
      visibility: hidden;
      transform: translateY(8px);
      transition: opacity 0.15s ease, transform 0.15s ease, visibility 0.15s;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    #language-picker.open {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    #language-picker::-webkit-scrollbar {
      width: 6px;
    }

    #language-picker::-webkit-scrollbar-track {
      background: transparent;
    }

    #language-picker::-webkit-scrollbar-thumb {
      background: var(--fg);
      opacity: 0.3;
      border-radius: 3px;
    }

    .language-option {
      padding: 6px 14px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      cursor: pointer;
      transition: background 0.1s ease;
      white-space: nowrap;
    }

    .language-option:hover {
      background: var(--toggle-hover);
    }

    .language-option.selected {
      background: var(--toggle-hover);
      font-weight: 600;
    }

    .language-option.auto-detect {
      border-bottom: 1px solid var(--toggle-hover);
      margin-bottom: 4px;
      padding-bottom: 8px;
      font-style: italic;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div id="editor-container">
    <pre id="highlight-layer"><code></code></pre>
    <textarea id="editor" autofocus spellcheck="false"></textarea>
  </div>
  <div id="status-bar">
    <button id="ruff-format" title="Format with Ruff">
      <span>format w/ ruff</span>
    </button>
    <button id="sql-format" title="Format with sqlformat">
      <span>format w/ sqlformat</span>
    </button>
    <button id="prettier-format" title="Format with Prettier (⌘F)">
      <span>format w/ prettier</span>
    </button>
    <button id="highlight-toggle" title="Toggle syntax highlighting">
      <span>syntax: on</span>
    </button>
    <div id="language-indicator" title="Change language">plaintext</div>
  </div>
  <div id="language-picker"></div>
  <div id="formatter-tooltip" class="formatter-tooltip"></div>
  <script>
    const hljs = require('highlight.js');
    const { exec, spawn } = require('child_process');
    
    // Limit auto-detection to these languages only
    hljs.configure({
      languages: [
        'javascript',
        'typescript',
        'python',
        'html',
        'css',
        'json',
        'bash',
        'shell',
        'sql',
        'go',
        'rust',
        'java',
        'c',
        'cpp',
        'ruby',
        'php',
        'swift',
        'kotlin',
        'yaml',
        'markdown',
        'scala',
        'haskell',
        'lua',
        'r',
        'perl'
      ]
    });
    
    const editor = document.getElementById('editor');
    const highlightLayer = document.getElementById('highlight-layer').querySelector('code');
    const languageIndicator = document.getElementById('language-indicator');
    const languagePicker = document.getElementById('language-picker');
    const highlightToggle = document.getElementById('highlight-toggle');
    const KEY = 'blackboard-content';
    const LANG_KEY = 'blackboard-language';
    const HIGHLIGHT_KEY = 'blackboard-highlighting';

    // Highlighting enabled state
    let highlightingEnabled = localStorage.getItem(HIGHLIGHT_KEY) !== 'false';

    // Minimum relevance score to apply syntax highlighting
    // Higher = more confident detection required
    const CONFIDENCE_THRESHOLD = 5;

    // Available languages for the picker (alphabetical)
    const AVAILABLE_LANGUAGES = [
      'bash',
      'c',
      'cpp',
      'css',
      'go',
      'haskell',
      'html',
      'java',
      'javascript',
      'json',
      'kotlin',
      'lua',
      'markdown',
      'perl',
      'php',
      'plaintext',
      'python',
      'r',
      'ruby',
      'rust',
      'scala',
      'shell',
      'sql',
      'swift',
      'typescript',
      'yaml'
    ];

    // Manual language override (null = auto-detect)
    let manualLanguage = localStorage.getItem(LANG_KEY) || null;

    // Ruff availability
    let ruffAvailable = false;
    const ruffFormatBtn = document.getElementById('ruff-format');

    // Check if ruff is available on system
    function checkRuffAvailable() {
      // Try common paths including user's local bin directories
      const pathsToTry = [
        process.env.HOME + '/.local/bin',
        process.env.HOME + '/.cargo/bin',
        '/usr/local/bin',
        '/opt/homebrew/bin'
      ].join(':') + ':' + (process.env.PATH || '');

      exec('ruff --version', { env: { ...process.env, PATH: pathsToTry } }, (error, stdout, stderr) => {
        ruffAvailable = !error;
        updateRuffButton();
      });
    }

    // Update ruff button visibility
    function updateRuffButton() {
      const isPython = currentLanguage === 'python' || manualLanguage === 'python';
      if (isPython && editor.value.trim()) {
        ruffFormatBtn.classList.add('visible');
        if (ruffAvailable) {
          ruffFormatBtn.classList.remove('unavailable');
          ruffFormatBtn.title = 'Format with Ruff (⌘F)';
        } else {
          ruffFormatBtn.classList.add('unavailable');
          ruffFormatBtn.title = 'Ruff not installed - click for info';
        }
      } else {
        ruffFormatBtn.classList.remove('visible');
        ruffFormatBtn.classList.remove('unavailable');
      }
    }

    // Format code with ruff
    function formatWithRuff() {
      if (!ruffAvailable) return;
      
      const code = editor.value;
      if (!code.trim()) return;

      ruffFormatBtn.classList.add('formatting');

      // Build PATH with common locations
      const pathsToTry = [
        process.env.HOME + '/.local/bin',
        process.env.HOME + '/.cargo/bin',
        '/usr/local/bin',
        '/opt/homebrew/bin'
      ].join(':') + ':' + (process.env.PATH || '');

      const ruff = spawn('ruff', ['format', '-'], {
        env: { ...process.env, PATH: pathsToTry }
      });

      let formattedCode = '';
      let errorOutput = '';

      ruff.stdout.on('data', (data) => {
        formattedCode += data.toString();
      });

      ruff.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      ruff.on('close', (exitCode) => {
        ruffFormatBtn.classList.remove('formatting');

        if (exitCode === 0 && formattedCode) {
          // Preserve cursor position roughly
          const cursorPos = editor.selectionStart;
          const ratio = cursorPos / code.length;
          
          editor.value = formattedCode;
          localStorage.setItem(KEY, formattedCode);
          
          // Restore cursor position proportionally
          const newPos = Math.round(ratio * formattedCode.length);
          editor.setSelectionRange(newPos, newPos);
          
          applyHighlighting();
        }
      });

      ruff.stdin.write(code);
      ruff.stdin.end();
    }

    // Ruff button click handler
    ruffFormatBtn.addEventListener('click', () => {
      if (ruffAvailable) {
        formatWithRuff();
      } else {
        showFormatterTooltip('ruff', 'uv tool install ruff');
      }
    });

    // Check for ruff on startup
    checkRuffAvailable();

    // sqlformat availability
    let sqlformatAvailable = false;
    const sqlFormatBtn = document.getElementById('sql-format');

    // Formatter tooltip
    const formatterTooltip = document.getElementById('formatter-tooltip');
    let tooltipTimeout = null;

    function showFormatterTooltip(formatter, installCmd) {
      clearTimeout(tooltipTimeout);
      formatterTooltip.innerHTML = `
        <div class="formatter-tooltip-title">
          <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>
          ${formatter} not installed
        </div>
        <div>To enable formatting, run:</div>
        <div style="margin-top: 6px;"><code>${installCmd}</code></div>
      `;
      formatterTooltip.classList.add('open');
      
      // Auto-hide after 5 seconds
      tooltipTimeout = setTimeout(() => {
        formatterTooltip.classList.remove('open');
      }, 5000);
    }

    function hideFormatterTooltip() {
      clearTimeout(tooltipTimeout);
      formatterTooltip.classList.remove('open');
    }

    // Check if sqlformat is available on system
    function checkSqlformatAvailable() {
      const pathsToTry = [
        process.env.HOME + '/.local/bin',
        process.env.HOME + '/.pyenv/shims',
        '/usr/local/bin',
        '/opt/homebrew/bin'
      ].join(':') + ':' + (process.env.PATH || '');

      exec('sqlformat --version', { env: { ...process.env, PATH: pathsToTry } }, (error, stdout, stderr) => {
        sqlformatAvailable = !error;
        updateSqlFormatButton();
      });
    }

    // Update sqlformat button visibility
    function updateSqlFormatButton() {
      const isSQL = currentLanguage === 'sql' || manualLanguage === 'sql';
      if (isSQL && editor.value.trim()) {
        sqlFormatBtn.classList.add('visible');
        if (sqlformatAvailable) {
          sqlFormatBtn.classList.remove('unavailable');
          sqlFormatBtn.title = 'Format with sqlformat (⌘F)';
        } else {
          sqlFormatBtn.classList.add('unavailable');
          sqlFormatBtn.title = 'sqlformat not installed - click for info';
        }
      } else {
        sqlFormatBtn.classList.remove('visible');
        sqlFormatBtn.classList.remove('unavailable');
      }
    }

    // Format code with sqlformat
    function formatWithSqlformat() {
      if (!sqlformatAvailable) return;
      
      const code = editor.value;
      if (!code.trim()) return;

      sqlFormatBtn.classList.add('formatting');

      const pathsToTry = [
        process.env.HOME + '/.local/bin',
        process.env.HOME + '/.pyenv/shims',
        '/usr/local/bin',
        '/opt/homebrew/bin'
      ].join(':') + ':' + (process.env.PATH || '');

      // sqlformat options: -r for reindent, -k upper for uppercase keywords
      const sqlformat = spawn('sqlformat', ['-r', '-k', 'upper', '-'], {
        env: { ...process.env, PATH: pathsToTry }
      });

      let formattedCode = '';
      let errorOutput = '';

      sqlformat.stdout.on('data', (data) => {
        formattedCode += data.toString();
      });

      sqlformat.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      sqlformat.on('close', (exitCode) => {
        sqlFormatBtn.classList.remove('formatting');

        if (exitCode === 0 && formattedCode) {
          const cursorPos = editor.selectionStart;
          const ratio = cursorPos / code.length;
          
          editor.value = formattedCode;
          localStorage.setItem(KEY, formattedCode);
          
          const newPos = Math.round(ratio * formattedCode.length);
          editor.setSelectionRange(newPos, newPos);
          
          applyHighlighting();
        }
      });

      sqlformat.stdin.write(code);
      sqlformat.stdin.end();
    }

    // sqlformat button click handler
    sqlFormatBtn.addEventListener('click', () => {
      if (sqlformatAvailable) {
        formatWithSqlformat();
      } else {
        showFormatterTooltip('sqlformat', 'uv tool install --from sqlparse sqlformat');
      }
    });

    // Check for sqlformat on startup
    checkSqlformatAvailable();

    // Prettier (bundled with app - always available)
    // Lazy load to avoid blocking startup
    let prettierModule = null;
    let prettierPlugins = {};
    
    const prettierFormatBtn = document.getElementById('prettier-format');

    // Languages supported by Prettier and their parser names + plugin names
    const PRETTIER_CONFIG = {
      'javascript': { parser: 'babel', pluginNames: ['babel', 'estree'] },
      'typescript': { parser: 'typescript', pluginNames: ['typescript', 'estree'] },
      'json': { parser: 'json', pluginNames: ['babel', 'estree'] },
      'html': { parser: 'html', pluginNames: ['html'] },
      'css': { parser: 'css', pluginNames: ['postcss'] },
      'markdown': { parser: 'markdown', pluginNames: ['markdown'] },
      'yaml': { parser: 'yaml', pluginNames: ['yaml'] }
    };

    // Lazy load prettier and required plugins
    function getPrettierPlugins(pluginNames) {
      if (!prettierModule) {
        prettierModule = require('prettier/standalone');
      }
      const plugins = [];
      for (const name of pluginNames) {
        if (!prettierPlugins[name]) {
          prettierPlugins[name] = require(`prettier/plugins/${name}`);
        }
        plugins.push(prettierPlugins[name]);
      }
      return plugins;
    }

    // Update prettier button visibility
    function updatePrettierButton() {
      const lang = manualLanguage || currentLanguage;
      const config = PRETTIER_CONFIG[lang];
      
      if (config && editor.value.trim()) {
        prettierFormatBtn.classList.add('visible');
        prettierFormatBtn.title = 'Format with Prettier (⌘F)';
      } else {
        prettierFormatBtn.classList.remove('visible');
      }
    }

    // Format code with Prettier
    async function formatWithPrettier() {
      const code = editor.value;
      if (!code.trim()) return;

      const lang = manualLanguage || currentLanguage;
      const config = PRETTIER_CONFIG[lang];
      if (!config) return;

      prettierFormatBtn.classList.add('formatting');

      try {
        const plugins = getPrettierPlugins(config.pluginNames);
        const formattedCode = await prettierModule.format(code, {
          parser: config.parser,
          plugins: plugins,
          tabWidth: 2,
          singleQuote: true,
          trailingComma: 'es5',
          printWidth: 100
        });

        // Preserve cursor position roughly
        const cursorPos = editor.selectionStart;
        const ratio = cursorPos / code.length;

        editor.value = formattedCode;
        localStorage.setItem(KEY, formattedCode);

        // Restore cursor position proportionally
        const newPos = Math.round(ratio * formattedCode.length);
        editor.setSelectionRange(newPos, newPos);

        applyHighlighting();
      } catch (err) {
        // Formatting failed (likely syntax error) - just ignore
        console.error('Prettier error:', err);
      } finally {
        prettierFormatBtn.classList.remove('formatting');
      }
    }

    // Prettier button click handler
    prettierFormatBtn.addEventListener('click', formatWithPrettier);

    // Build the language picker dropdown
    function buildLanguagePicker() {
      languagePicker.innerHTML = '';
      
      // Auto-detect option
      const autoOption = document.createElement('div');
      autoOption.className = 'language-option auto-detect' + (manualLanguage === null ? ' selected' : '');
      autoOption.textContent = 'Auto-detect';
      autoOption.addEventListener('click', () => selectLanguage(null));
      languagePicker.appendChild(autoOption);

      // Language options
      AVAILABLE_LANGUAGES.forEach(lang => {
        const option = document.createElement('div');
        option.className = 'language-option' + (manualLanguage === lang ? ' selected' : '');
        option.textContent = lang;
        option.addEventListener('click', () => selectLanguage(lang));
        languagePicker.appendChild(option);
      });
    }

    // Select a language
    function selectLanguage(lang) {
      manualLanguage = lang;
      if (lang) {
        localStorage.setItem(LANG_KEY, lang);
      } else {
        localStorage.removeItem(LANG_KEY);
      }
      closePicker();
      applyHighlighting();
    }

    // Toggle picker visibility
    function togglePicker() {
      const isOpen = languagePicker.classList.contains('open');
      if (isOpen) {
        closePicker();
      } else {
        buildLanguagePicker();
        languagePicker.classList.add('open');
      }
    }

    function closePicker() {
      languagePicker.classList.remove('open');
    }

    // Language indicator click handler
    languageIndicator.addEventListener('click', (e) => {
      e.stopPropagation();
      togglePicker();
    });

    // Close picker when clicking outside
    document.addEventListener('click', (e) => {
      if (!languagePicker.contains(e.target) && e.target !== languageIndicator) {
        closePicker();
      }
      // Close formatter tooltip when clicking outside
      if (!formatterTooltip.contains(e.target) && 
          !ruffFormatBtn.contains(e.target) && 
          !sqlFormatBtn.contains(e.target)) {
        hideFormatterTooltip();
      }
    });

    // Close picker and tooltip on escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closePicker();
        hideFormatterTooltip();
      }
    });

    // Cmd+F to format (if a formatter is available)
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'f') {
        const lang = manualLanguage || currentLanguage;
        
        // Check if we have an available formatter for this language
        if (lang === 'python' && ruffAvailable) {
          e.preventDefault();
          formatWithRuff();
        } else if (lang === 'sql' && sqlformatAvailable) {
          e.preventDefault();
          formatWithSqlformat();
        } else if (PRETTIER_CONFIG[lang]) {
          e.preventDefault();
          formatWithPrettier();
        }
        // Otherwise, let default behavior (browser find) happen
      }
    });

    // Escape HTML to prevent XSS and display issues
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Debounce function for performance
    function debounce(fn, delay) {
      let timeout;
      return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    // Track current detected language
    let currentLanguage = null;

    // Update highlight toggle button state
    function updateHighlightToggle() {
      const span = highlightToggle.querySelector('span');
      if (highlightingEnabled) {
        highlightToggle.classList.remove('disabled');
        highlightToggle.title = 'Disable syntax highlighting';
        span.textContent = 'syntax: on';
      } else {
        highlightToggle.classList.add('disabled');
        highlightToggle.title = 'Enable syntax highlighting';
        span.textContent = 'syntax: off';
      }
    }

    // Toggle syntax highlighting
    function toggleHighlighting() {
      highlightingEnabled = !highlightingEnabled;
      localStorage.setItem(HIGHLIGHT_KEY, highlightingEnabled ? 'true' : 'false');
      updateHighlightToggle();
      applyHighlighting();
    }

    // Highlight toggle click handler
    highlightToggle.addEventListener('click', toggleHighlighting);

    // Apply highlighting based on current language (manual or detected)
    function applyHighlighting() {
      const text = editor.value;
      
      if (!text.trim()) {
        highlightLayer.innerHTML = '';
        highlightLayer.className = '';
        currentLanguage = null;
        updateIndicator('plaintext');
        return;
      }

      // If highlighting is disabled, show plain text
      if (!highlightingEnabled) {
        highlightLayer.innerHTML = escapeHtml(text);
        highlightLayer.className = '';
        // Still detect language for indicator but don't highlight
        if (manualLanguage) {
          updateIndicator(manualLanguage);
        } else {
          try {
            const result = hljs.highlightAuto(text);
            if (result.relevance >= CONFIDENCE_THRESHOLD && result.language) {
              currentLanguage = result.language;
              updateIndicator(result.language);
            } else {
              currentLanguage = null;
              updateIndicator('plaintext');
            }
          } catch (e) {
            currentLanguage = null;
            updateIndicator('plaintext');
          }
        }
        return;
      }

      if (manualLanguage) {
        // Use manually selected language
        try {
          const result = hljs.highlight(text, { language: manualLanguage });
          currentLanguage = manualLanguage;
          highlightLayer.innerHTML = result.value;
          highlightLayer.className = `hljs language-${manualLanguage}`;
          updateIndicator(manualLanguage);
        } catch (e) {
          highlightLayer.innerHTML = escapeHtml(text);
          highlightLayer.className = '';
          updateIndicator('plaintext');
        }
      } else {
        // Auto-detect
        detectAndHighlight();
      }
    }

    // Update the language indicator display
    function updateIndicator(lang) {
      languageIndicator.textContent = lang;
      languageIndicator.classList.add('visible');
      
      if (lang === 'plaintext') {
        highlightToggle.classList.remove('visible');
      } else {
        highlightToggle.classList.add('visible');
      }
      
      // darkToggle.classList.add('visible');
      updateRuffButton();
      updateSqlFormatButton();
      updatePrettierButton();
    }

    // Immediately update display (plain text or re-apply current highlighting)
    function updateDisplayImmediate() {
      const text = editor.value;
      
      if (!text.trim()) {
        highlightLayer.innerHTML = '';
        highlightLayer.className = '';
        currentLanguage = null;
        updateIndicator('plaintext');
        return;
      }

      // If highlighting is disabled, show plain text
      if (!highlightingEnabled) {
        highlightLayer.innerHTML = escapeHtml(text);
        return;
      }

      const langToUse = manualLanguage || currentLanguage;
      if (langToUse) {
        // Re-apply known language highlighting immediately
        try {
          const result = hljs.highlight(text, { language: langToUse });
          highlightLayer.innerHTML = result.value;
        } catch (e) {
          highlightLayer.innerHTML = escapeHtml(text);
        }
      } else {
        // No language detected yet, show plain text
        highlightLayer.innerHTML = escapeHtml(text);
      }
    }

    // Expensive language detection (debounced)
    function detectAndHighlight() {
      const text = editor.value;
      
      if (!text.trim()) {
        currentLanguage = null;
        updateIndicator('plaintext');
        return;
      }

      // Skip auto-detection if manual language is set
      if (manualLanguage) {
        return;
      }

      try {
        const result = hljs.highlightAuto(text);
        
        if (result.relevance >= CONFIDENCE_THRESHOLD && result.language) {
          currentLanguage = result.language;
          highlightLayer.innerHTML = result.value;
          highlightLayer.className = `hljs language-${result.language}`;
          updateIndicator(result.language);
        } else {
          currentLanguage = null;
          highlightLayer.innerHTML = escapeHtml(text);
          highlightLayer.className = '';
          updateIndicator('plaintext');
        }
      } catch (e) {
        currentLanguage = null;
        highlightLayer.innerHTML = escapeHtml(text);
        highlightLayer.className = '';
        updateIndicator('plaintext');
      }
    }

    // Sync scroll between editor and highlight layer
    function syncScroll() {
      const pre = document.getElementById('highlight-layer');
      pre.scrollTop = editor.scrollTop;
      pre.scrollLeft = editor.scrollLeft;
    }

    // Debounced language detection
    const debouncedDetect = debounce(detectAndHighlight, 300);

    // Initialize
    editor.value = localStorage.getItem(KEY) || '';
    updateHighlightToggle();
    applyHighlighting();

    editor.addEventListener('input', () => {
      localStorage.setItem(KEY, editor.value);
      updateDisplayImmediate();  // Instant text update
      debouncedDetect();         // Delayed language detection
    });

    editor.addEventListener('scroll', syncScroll);
  </script>
</body>
</html>
