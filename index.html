<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Blackboard</title>
  <link rel="stylesheet" href="./node_modules/highlight.js/styles/github-dark.css" id="hljs-dark">
  <link rel="stylesheet" href="./node_modules/highlight.js/styles/github.css" id="hljs-light" disabled>
  <style>
    :root {
      --bg: #0d0d0d;
      --fg: #e0e0e0;
      --toggle-bg: #2a2a2a;
      --toggle-hover: #3a3a3a;
    }

    :root.light {
      --bg: #faf9f7;
      --fg: #1a1a1a;
      --toggle-bg: #e8e6e3;
      --toggle-hover: #dbd8d4;
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: var(--bg);
      transition: background 0.3s ease;
    }

    #editor-container {
      position: relative;
      width: 100%;
      height: 100%;
    }

    #editor, #highlight-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      padding: 12px;
      font-family: Monaco, Menlo, monospace;
      font-size: 13px;
      line-height: 1.7;
      border: none;
      margin: 0;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    #editor {
      outline: none;
      resize: none;
      background: transparent;
      color: transparent;
      caret-color: var(--fg);
      z-index: 2;
      -webkit-text-fill-color: transparent;
    }

    #editor::selection {
      background: rgba(100, 100, 255, 0.3);
    }

    #editor::-moz-selection {
      background: rgba(100, 100, 255, 0.3);
    }

    #highlight-layer {
      z-index: 1;
      pointer-events: none;
      background: var(--bg);
      color: var(--fg);
      overflow: hidden;
      transition: background 0.3s ease, color 0.3s ease;
    }

    #highlight-layer code {
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
      background: transparent !important;
      padding: 0 !important;
      display: block;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    /* Override highlight.js background */
    #highlight-layer code.hljs {
      background: transparent !important;
      padding: 0 !important;
    }

    #dark-toggle {
      padding: 4px 8px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      background: var(--toggle-bg);
      border: none;
      border-radius: 4px;
      opacity: 0;
      transition: opacity 0.3s ease, background 0.2s ease;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #dark-toggle:hover {
      background: var(--toggle-hover);
    }

    #dark-toggle.visible {
      opacity: 0.7;
    }

    #dark-toggle.visible:hover {
      opacity: 1;
    }

    #dark-toggle svg {
      width: 12px;
      height: 12px;
      fill: currentColor;
    }

    .sun-icon { display: block; }
    .moon-icon { display: none; }

    :root.light .sun-icon { display: none; }
    :root.light .moon-icon { display: block; }

    /* Language indicator */
    #language-indicator {
      padding: 4px 10px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      background: var(--toggle-bg);
      border-radius: 4px;
      opacity: 0;
      transition: opacity 0.3s ease, background 0.2s ease;
      cursor: pointer;
      user-select: none;
    }

    #language-indicator:hover {
      background: var(--toggle-hover);
    }

    #language-indicator.visible {
      opacity: 0.7;
    }

    #language-indicator.visible:hover {
      opacity: 1;
    }

    /* Status bar container */
    #status-bar {
      position: fixed;
      bottom: 16px;
      right: 16px;
      display: flex;
      align-items: center;
      gap: 6px;
      z-index: 100;
    }

    /* Highlight toggle button */
    #highlight-toggle {
      padding: 4px 8px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      background: var(--toggle-bg);
      border: none;
      border-radius: 4px;
      opacity: 0;
      transition: opacity 0.3s ease, background 0.2s ease;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    #highlight-toggle:hover {
      background: var(--toggle-hover);
    }

    #highlight-toggle.visible {
      opacity: 0.7;
    }

    #highlight-toggle.visible:hover {
      opacity: 1;
    }

    #highlight-toggle svg {
      width: 12px;
      height: 12px;
      fill: currentColor;
    }

    #highlight-toggle.disabled {
      opacity: 0.5;
      position: relative;
    }


    #highlight-toggle.disabled.visible {
      opacity: 0.5;
    }

    #highlight-toggle.disabled.visible:hover {
      opacity: 0.7;
    }

    /* Ruff format button */
    #ruff-format {
      padding: 4px 10px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      background: var(--toggle-bg);
      border: none;
      border-radius: 4px;
      opacity: 0;
      display: none;
      transition: opacity 0.3s ease, background 0.2s ease;
      cursor: pointer;
      user-select: none;
      align-items: center;
      gap: 5px;
    }

    #ruff-format:hover {
      background: var(--toggle-hover);
    }

    #ruff-format.visible {
      opacity: 0.7;
      display: flex;
    }

    #ruff-format.visible:hover {
      opacity: 1;
    }

    #ruff-format.formatting {
      opacity: 0.5;
      pointer-events: none;
    }

    #ruff-format.unavailable {
      opacity: 0.4;
      cursor: default;
    }

    #ruff-format.unavailable:hover {
      background: var(--toggle-bg);
      opacity: 0.4;
    }

    /* SQL format button */
    #sql-format {
      padding: 4px 10px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      background: var(--toggle-bg);
      border: none;
      border-radius: 4px;
      opacity: 0;
      display: none;
      transition: opacity 0.3s ease, background 0.2s ease;
      cursor: pointer;
      user-select: none;
      align-items: center;
      gap: 5px;
    }

    #sql-format:hover {
      background: var(--toggle-hover);
    }

    #sql-format.visible {
      opacity: 0.7;
      display: flex;
    }

    #sql-format.visible:hover {
      opacity: 1;
    }

    #sql-format.formatting {
      opacity: 0.5;
      pointer-events: none;
    }

    #sql-format.unavailable {
      opacity: 0.4;
      cursor: default;
    }

    #sql-format.unavailable:hover {
      background: var(--toggle-bg);
      opacity: 0.4;
    }

    /* Formatter tooltip */
    .formatter-tooltip {
      position: fixed;
      bottom: 54px;
      right: 16px;
      background: var(--toggle-bg);
      border-radius: 6px;
      padding: 10px 14px;
      max-width: 280px;
      z-index: 102;
      opacity: 0;
      visibility: hidden;
      transform: translateY(8px);
      transition: opacity 0.15s ease, transform 0.15s ease, visibility 0.15s;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      line-height: 1.5;
    }

    .formatter-tooltip.open {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .formatter-tooltip-title {
      font-weight: 600;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .formatter-tooltip-title svg {
      width: 14px;
      height: 14px;
      fill: currentColor;
      opacity: 0.7;
    }

    .formatter-tooltip code {
      background: var(--toggle-hover);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
    }

    /* Language picker dropdown */
    #language-picker {
      position: fixed;
      bottom: 44px;
      right: 16px;
      background: var(--toggle-bg);
      border-radius: 6px;
      padding: 6px 0;
      max-height: 280px;
      overflow-y: auto;
      z-index: 101;
      opacity: 0;
      visibility: hidden;
      transform: translateY(8px);
      transition: opacity 0.15s ease, transform 0.15s ease, visibility 0.15s;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    #language-picker.open {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    #language-picker::-webkit-scrollbar {
      width: 6px;
    }

    #language-picker::-webkit-scrollbar-track {
      background: transparent;
    }

    #language-picker::-webkit-scrollbar-thumb {
      background: var(--fg);
      opacity: 0.3;
      border-radius: 3px;
    }

    .language-option {
      padding: 6px 14px;
      font-family: Monaco, Menlo, monospace;
      font-size: 11px;
      color: var(--fg);
      cursor: pointer;
      transition: background 0.1s ease;
      white-space: nowrap;
    }

    .language-option:hover {
      background: var(--toggle-hover);
    }

    .language-option.selected {
      background: var(--toggle-hover);
      font-weight: 600;
    }

    .language-option.auto-detect {
      border-bottom: 1px solid var(--toggle-hover);
      margin-bottom: 4px;
      padding-bottom: 8px;
      font-style: italic;
      opacity: 0.8;
    }
  </style>
  <script>
    if (localStorage.getItem('blackboard-theme') === 'light') {
      document.documentElement.classList.add('light');
    }
  </script>
</head>
<body>
  <div id="editor-container">
    <pre id="highlight-layer"><code></code></pre>
    <textarea id="editor" autofocus spellcheck="false"></textarea>
  </div>
  <div id="status-bar">
    <button id="ruff-format" title="Format with Ruff">
      <span>prettify</span>
    </button>
    <button id="sql-format" title="Format with sqlformat">
      <span>prettify</span>
    </button>
    <button id="highlight-toggle" title="Toggle syntax highlighting">
      <span>syntax: on</span>
    </button>
    <div id="language-indicator" title="Change language">plaintext</div>
    <!-- <button id="dark-toggle" title="Toggle dark mode">
      <svg class="moon-icon" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
      <svg class="sun-icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><line x1="12" y1="21" x2="12" y2="23" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><line x1="1" y1="12" x2="3" y2="12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><line x1="21" y1="12" x2="23" y2="12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
    </button> -->
  </div>
  <div id="language-picker"></div>
  <div id="formatter-tooltip" class="formatter-tooltip"></div>
  <script>
    const hljs = require('highlight.js');
    const { exec, spawn } = require('child_process');
    
    // Limit auto-detection to these languages only
    hljs.configure({
      languages: [
        'javascript',
        'typescript',
        'python',
        'html',
        'css',
        'json',
        'bash',
        'shell',
        'sql',
        'go',
        'rust',
        'java',
        'c',
        'cpp',
        'ruby',
        'php',
        'swift',
        'kotlin',
        'yaml',
        'markdown',
        'scala',
        'haskell',
        'lua',
        'r',
        'perl'
      ]
    });
    
    const editor = document.getElementById('editor');
    const highlightLayer = document.getElementById('highlight-layer').querySelector('code');
    const languageIndicator = document.getElementById('language-indicator');
    const languagePicker = document.getElementById('language-picker');
    const highlightToggle = document.getElementById('highlight-toggle');
    // const darkToggle = document.getElementById('dark-toggle');
    const KEY = 'blackboard-content';
    const THEME_KEY = 'blackboard-theme';
    const LANG_KEY = 'blackboard-language';
    const HIGHLIGHT_KEY = 'blackboard-highlighting';

    // Highlighting enabled state
    let highlightingEnabled = localStorage.getItem(HIGHLIGHT_KEY) !== 'false';

    // Minimum relevance score to apply syntax highlighting
    // Higher = more confident detection required
    const CONFIDENCE_THRESHOLD = 5;

    // Available languages for the picker (alphabetical)
    const AVAILABLE_LANGUAGES = [
      'bash',
      'c',
      'cpp',
      'css',
      'go',
      'haskell',
      'html',
      'java',
      'javascript',
      'json',
      'kotlin',
      'lua',
      'markdown',
      'perl',
      'php',
      'plaintext',
      'python',
      'r',
      'ruby',
      'rust',
      'scala',
      'shell',
      'sql',
      'swift',
      'typescript',
      'yaml'
    ];

    // Manual language override (null = auto-detect)
    let manualLanguage = localStorage.getItem(LANG_KEY) || null;

    // Ruff availability
    let ruffAvailable = false;
    const ruffFormatBtn = document.getElementById('ruff-format');

    // Check if ruff is available on system
    function checkRuffAvailable() {
      // Try common paths including user's local bin directories
      const pathsToTry = [
        process.env.HOME + '/.local/bin',
        process.env.HOME + '/.cargo/bin',
        '/usr/local/bin',
        '/opt/homebrew/bin'
      ].join(':') + ':' + (process.env.PATH || '');

      exec('ruff --version', { env: { ...process.env, PATH: pathsToTry } }, (error, stdout, stderr) => {
        ruffAvailable = !error;
        updateRuffButton();
      });
    }

    // Update ruff button visibility
    function updateRuffButton() {
      const isPython = currentLanguage === 'python' || manualLanguage === 'python';
      if (isPython && editor.value.trim()) {
        ruffFormatBtn.classList.add('visible');
        if (ruffAvailable) {
          ruffFormatBtn.classList.remove('unavailable');
          ruffFormatBtn.title = 'Format with Ruff (⌘F)';
        } else {
          ruffFormatBtn.classList.add('unavailable');
          ruffFormatBtn.title = 'Ruff not installed - click for info';
        }
      } else {
        ruffFormatBtn.classList.remove('visible');
        ruffFormatBtn.classList.remove('unavailable');
      }
    }

    // Format code with ruff
    function formatWithRuff() {
      if (!ruffAvailable) return;
      
      const code = editor.value;
      if (!code.trim()) return;

      ruffFormatBtn.classList.add('formatting');

      // Build PATH with common locations
      const pathsToTry = [
        process.env.HOME + '/.local/bin',
        process.env.HOME + '/.cargo/bin',
        '/usr/local/bin',
        '/opt/homebrew/bin'
      ].join(':') + ':' + (process.env.PATH || '');

      const ruff = spawn('ruff', ['format', '-'], {
        env: { ...process.env, PATH: pathsToTry }
      });

      let formattedCode = '';
      let errorOutput = '';

      ruff.stdout.on('data', (data) => {
        formattedCode += data.toString();
      });

      ruff.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      ruff.on('close', (exitCode) => {
        ruffFormatBtn.classList.remove('formatting');

        if (exitCode === 0 && formattedCode) {
          // Preserve cursor position roughly
          const cursorPos = editor.selectionStart;
          const ratio = cursorPos / code.length;
          
          editor.value = formattedCode;
          localStorage.setItem(KEY, formattedCode);
          
          // Restore cursor position proportionally
          const newPos = Math.round(ratio * formattedCode.length);
          editor.setSelectionRange(newPos, newPos);
          
          applyHighlighting();
        }
      });

      ruff.stdin.write(code);
      ruff.stdin.end();
    }

    // Ruff button click handler
    ruffFormatBtn.addEventListener('click', () => {
      if (ruffAvailable) {
        formatWithRuff();
      } else {
        showFormatterTooltip('ruff', 'uv tool install ruff');
      }
    });

    // Check for ruff on startup
    checkRuffAvailable();

    // sqlformat availability
    let sqlformatAvailable = false;
    const sqlFormatBtn = document.getElementById('sql-format');

    // Formatter tooltip
    const formatterTooltip = document.getElementById('formatter-tooltip');
    let tooltipTimeout = null;

    function showFormatterTooltip(formatter, installCmd) {
      clearTimeout(tooltipTimeout);
      formatterTooltip.innerHTML = `
        <div class="formatter-tooltip-title">
          <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>
          ${formatter} not installed
        </div>
        <div>To enable formatting, run:</div>
        <div style="margin-top: 6px;"><code>${installCmd}</code></div>
      `;
      formatterTooltip.classList.add('open');
      
      // Auto-hide after 5 seconds
      tooltipTimeout = setTimeout(() => {
        formatterTooltip.classList.remove('open');
      }, 5000);
    }

    function hideFormatterTooltip() {
      clearTimeout(tooltipTimeout);
      formatterTooltip.classList.remove('open');
    }

    // Check if sqlformat is available on system
    function checkSqlformatAvailable() {
      const pathsToTry = [
        process.env.HOME + '/.local/bin',
        process.env.HOME + '/.pyenv/shims',
        '/usr/local/bin',
        '/opt/homebrew/bin'
      ].join(':') + ':' + (process.env.PATH || '');

      exec('sqlformat --version', { env: { ...process.env, PATH: pathsToTry } }, (error, stdout, stderr) => {
        sqlformatAvailable = !error;
        updateSqlFormatButton();
      });
    }

    // Update sqlformat button visibility
    function updateSqlFormatButton() {
      const isSQL = currentLanguage === 'sql' || manualLanguage === 'sql';
      if (isSQL && editor.value.trim()) {
        sqlFormatBtn.classList.add('visible');
        if (sqlformatAvailable) {
          sqlFormatBtn.classList.remove('unavailable');
          sqlFormatBtn.title = 'Format with sqlformat (⌘F)';
        } else {
          sqlFormatBtn.classList.add('unavailable');
          sqlFormatBtn.title = 'sqlformat not installed - click for info';
        }
      } else {
        sqlFormatBtn.classList.remove('visible');
        sqlFormatBtn.classList.remove('unavailable');
      }
    }

    // Format code with sqlformat
    function formatWithSqlformat() {
      if (!sqlformatAvailable) return;
      
      const code = editor.value;
      if (!code.trim()) return;

      sqlFormatBtn.classList.add('formatting');

      const pathsToTry = [
        process.env.HOME + '/.local/bin',
        process.env.HOME + '/.pyenv/shims',
        '/usr/local/bin',
        '/opt/homebrew/bin'
      ].join(':') + ':' + (process.env.PATH || '');

      // sqlformat options: -r for reindent, -k upper for uppercase keywords
      const sqlformat = spawn('sqlformat', ['-r', '-k', 'upper', '-'], {
        env: { ...process.env, PATH: pathsToTry }
      });

      let formattedCode = '';
      let errorOutput = '';

      sqlformat.stdout.on('data', (data) => {
        formattedCode += data.toString();
      });

      sqlformat.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      sqlformat.on('close', (exitCode) => {
        sqlFormatBtn.classList.remove('formatting');

        if (exitCode === 0 && formattedCode) {
          const cursorPos = editor.selectionStart;
          const ratio = cursorPos / code.length;
          
          editor.value = formattedCode;
          localStorage.setItem(KEY, formattedCode);
          
          const newPos = Math.round(ratio * formattedCode.length);
          editor.setSelectionRange(newPos, newPos);
          
          applyHighlighting();
        }
      });

      sqlformat.stdin.write(code);
      sqlformat.stdin.end();
    }

    // sqlformat button click handler
    sqlFormatBtn.addEventListener('click', () => {
      if (sqlformatAvailable) {
        formatWithSqlformat();
      } else {
        showFormatterTooltip('sqlformat', 'uv tool install --from sqlparse sqlformat');
      }
    });

    // Check for sqlformat on startup
    checkSqlformatAvailable();

    // Build the language picker dropdown
    function buildLanguagePicker() {
      languagePicker.innerHTML = '';
      
      // Auto-detect option
      const autoOption = document.createElement('div');
      autoOption.className = 'language-option auto-detect' + (manualLanguage === null ? ' selected' : '');
      autoOption.textContent = 'Auto-detect';
      autoOption.addEventListener('click', () => selectLanguage(null));
      languagePicker.appendChild(autoOption);

      // Language options
      AVAILABLE_LANGUAGES.forEach(lang => {
        const option = document.createElement('div');
        option.className = 'language-option' + (manualLanguage === lang ? ' selected' : '');
        option.textContent = lang;
        option.addEventListener('click', () => selectLanguage(lang));
        languagePicker.appendChild(option);
      });
    }

    // Select a language
    function selectLanguage(lang) {
      manualLanguage = lang;
      if (lang) {
        localStorage.setItem(LANG_KEY, lang);
      } else {
        localStorage.removeItem(LANG_KEY);
      }
      closePicker();
      applyHighlighting();
    }

    // Toggle picker visibility
    function togglePicker() {
      const isOpen = languagePicker.classList.contains('open');
      if (isOpen) {
        closePicker();
      } else {
        buildLanguagePicker();
        languagePicker.classList.add('open');
      }
    }

    function closePicker() {
      languagePicker.classList.remove('open');
    }

    // Language indicator click handler
    languageIndicator.addEventListener('click', (e) => {
      e.stopPropagation();
      togglePicker();
    });

    // Close picker when clicking outside
    document.addEventListener('click', (e) => {
      if (!languagePicker.contains(e.target) && e.target !== languageIndicator) {
        closePicker();
      }
      // Close formatter tooltip when clicking outside
      if (!formatterTooltip.contains(e.target) && 
          !ruffFormatBtn.contains(e.target) && 
          !sqlFormatBtn.contains(e.target)) {
        hideFormatterTooltip();
      }
    });

    // Close picker and tooltip on escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closePicker();
        hideFormatterTooltip();
      }
    });

    // Cmd+F to format (if a formatter is available)
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'f') {
        const lang = manualLanguage || currentLanguage;
        
        // Check if we have an available formatter for this language
        if (lang === 'python' && ruffAvailable) {
          e.preventDefault();
          formatWithRuff();
        } else if (lang === 'sql' && sqlformatAvailable) {
          e.preventDefault();
          formatWithSqlformat();
        }
        // Otherwise, let default behavior (browser find) happen
      }
    });

    // Escape HTML to prevent XSS and display issues
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Debounce function for performance
    function debounce(fn, delay) {
      let timeout;
      return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    // Track current detected language
    let currentLanguage = null;

    // Update highlight toggle button state
    function updateHighlightToggle() {
      const span = highlightToggle.querySelector('span');
      if (highlightingEnabled) {
        highlightToggle.classList.remove('disabled');
        highlightToggle.title = 'Disable syntax highlighting';
        span.textContent = 'syntax: on';
      } else {
        highlightToggle.classList.add('disabled');
        highlightToggle.title = 'Enable syntax highlighting';
        span.textContent = 'syntax: off';
      }
    }

    // Toggle syntax highlighting
    function toggleHighlighting() {
      highlightingEnabled = !highlightingEnabled;
      localStorage.setItem(HIGHLIGHT_KEY, highlightingEnabled ? 'true' : 'false');
      updateHighlightToggle();
      applyHighlighting();
    }

    // Highlight toggle click handler
    highlightToggle.addEventListener('click', toggleHighlighting);

    // Apply highlighting based on current language (manual or detected)
    function applyHighlighting() {
      const text = editor.value;
      
      if (!text.trim()) {
        highlightLayer.innerHTML = '';
        highlightLayer.className = '';
        currentLanguage = null;
        updateIndicator('plaintext');
        return;
      }

      // If highlighting is disabled, show plain text
      if (!highlightingEnabled) {
        highlightLayer.innerHTML = escapeHtml(text);
        highlightLayer.className = '';
        // Still detect language for indicator but don't highlight
        if (manualLanguage) {
          updateIndicator(manualLanguage);
        } else {
          try {
            const result = hljs.highlightAuto(text);
            if (result.relevance >= CONFIDENCE_THRESHOLD && result.language) {
              currentLanguage = result.language;
              updateIndicator(result.language);
            } else {
              currentLanguage = null;
              updateIndicator('plaintext');
            }
          } catch (e) {
            currentLanguage = null;
            updateIndicator('plaintext');
          }
        }
        return;
      }

      if (manualLanguage) {
        // Use manually selected language
        try {
          const result = hljs.highlight(text, { language: manualLanguage });
          currentLanguage = manualLanguage;
          highlightLayer.innerHTML = result.value;
          highlightLayer.className = `hljs language-${manualLanguage}`;
          updateIndicator(manualLanguage);
        } catch (e) {
          highlightLayer.innerHTML = escapeHtml(text);
          highlightLayer.className = '';
          updateIndicator('plaintext');
        }
      } else {
        // Auto-detect
        detectAndHighlight();
      }
    }

    // Update the language indicator display
    function updateIndicator(lang) {
      languageIndicator.textContent = lang;
      languageIndicator.classList.add('visible');
      highlightToggle.classList.add('visible');
      // darkToggle.classList.add('visible');
      updateRuffButton();
      updateSqlFormatButton();
    }

    // Immediately update display (plain text or re-apply current highlighting)
    function updateDisplayImmediate() {
      const text = editor.value;
      
      if (!text.trim()) {
        highlightLayer.innerHTML = '';
        highlightLayer.className = '';
        currentLanguage = null;
        updateIndicator('plaintext');
        return;
      }

      // If highlighting is disabled, show plain text
      if (!highlightingEnabled) {
        highlightLayer.innerHTML = escapeHtml(text);
        return;
      }

      const langToUse = manualLanguage || currentLanguage;
      if (langToUse) {
        // Re-apply known language highlighting immediately
        try {
          const result = hljs.highlight(text, { language: langToUse });
          highlightLayer.innerHTML = result.value;
        } catch (e) {
          highlightLayer.innerHTML = escapeHtml(text);
        }
      } else {
        // No language detected yet, show plain text
        highlightLayer.innerHTML = escapeHtml(text);
      }
    }

    // Expensive language detection (debounced)
    function detectAndHighlight() {
      const text = editor.value;
      
      if (!text.trim()) {
        currentLanguage = null;
        updateIndicator('plaintext');
        return;
      }

      // Skip auto-detection if manual language is set
      if (manualLanguage) {
        return;
      }

      try {
        const result = hljs.highlightAuto(text);
        
        if (result.relevance >= CONFIDENCE_THRESHOLD && result.language) {
          currentLanguage = result.language;
          highlightLayer.innerHTML = result.value;
          highlightLayer.className = `hljs language-${result.language}`;
          updateIndicator(result.language);
        } else {
          currentLanguage = null;
          highlightLayer.innerHTML = escapeHtml(text);
          highlightLayer.className = '';
          updateIndicator('plaintext');
        }
      } catch (e) {
        currentLanguage = null;
        highlightLayer.innerHTML = escapeHtml(text);
        highlightLayer.className = '';
        updateIndicator('plaintext');
      }
    }

    // Sync scroll between editor and highlight layer
    function syncScroll() {
      const pre = document.getElementById('highlight-layer');
      pre.scrollTop = editor.scrollTop;
      pre.scrollLeft = editor.scrollLeft;
    }

    // Debounced language detection
    const debouncedDetect = debounce(detectAndHighlight, 300);

    // Initialize
    editor.value = localStorage.getItem(KEY) || '';
    updateHighlightToggle();
    applyHighlighting();

    editor.addEventListener('input', () => {
      localStorage.setItem(KEY, editor.value);
      updateDisplayImmediate();  // Instant text update
      debouncedDetect();         // Delayed language detection
    });

    editor.addEventListener('scroll', syncScroll);

    // Dark mode toggle
    const root = document.documentElement;
    const hljsDark = document.getElementById('hljs-dark');
    const hljsLight = document.getElementById('hljs-light');

    function updateThemeStyles() {
      const isLight = root.classList.contains('light');
      hljsDark.disabled = isLight;
      hljsLight.disabled = !isLight;
    }

    updateThemeStyles();
    // darkToggle.classList.add('visible');

    // darkToggle.addEventListener('click', () => {
    //   root.classList.toggle('light');
    //   localStorage.setItem(THEME_KEY, root.classList.contains('light') ? 'light' : 'dark');
    //   updateThemeStyles();
    // });
  </script>
</body>
</html>
